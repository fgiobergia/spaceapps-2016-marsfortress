// Generated by CoffeeScript 1.10.0
(function() {
  var AssertionError, BUILDING_TYPES, Building, BuildingType, Experiment, Game, Map, RESOURCE_TYPES, ResourceState, ResourceType, assert,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty,
    slice = [].slice;

  AssertionError = (function(superClass) {
    extend(AssertionError, superClass);

    function AssertionError() {
      return AssertionError.__super__.constructor.apply(this, arguments);
    }

    return AssertionError;

  })(Error);

  assert = function(cond) {
    if (!cond) {
      throw new AssertionError();
    }
  };

  RESOURCE_TYPES = {};

  ResourceType = (function() {
    function ResourceType(args) {
      this.name = args.name, this.symbol = args.symbol, this.descr = args.descr;
      if (RESOURCE_TYPES[this.name] != null) {
        console.warn("Overwriting resource named " + this.name);
      }
      RESOURCE_TYPES[this.name] = this;
    }

    return ResourceType;

  })();

  ResourceState = (function() {
    function ResourceState(args) {
      var ref;
      this.type = args.type, this.qty = args.qty, this.limit = (ref = args.limit) != null ? ref : 0;
      this.balance = [];
    }

    ResourceState.prototype.clearBalance = function() {
      return this.balance = [];
    };

    ResourceState.prototype.declare = function(qty, why) {
      return this.balance.append({
        qty: qty,
        why: why
      });
    };

    ResourceState.prototype.endTurn = function() {
      var k, len, qty, ref, ref1, results, why;
      ref = this.balance;
      results = [];
      for (k = 0, len = ref.length; k < len; k++) {
        ref1 = ref[k], qty = ref1.qty, why = ref1.why;
        console.log("Resource " + this.type.name + ": " + qty + ": " + why);
        results.push(this.qty += qty);
      }
      return results;
    };

    return ResourceState;

  })();

  BUILDING_TYPES = {};

  BuildingType = (function() {
    function BuildingType(args) {
      var ref;
      this.name = args.name, this.image = args.image, this.size = args.size, this.declareResources = (ref = args.declareResources) != null ? ref : (function(game) {}), this.descr = args.descr;
      if (BUILDING_TYPES[this.name] != null) {
        console.warn("Overwriting resource named " + this.name);
      }
      BUILDING_TYPES[this.name] = this;
    }

    return BuildingType;

  })();

  Building = (function() {
    function Building(args) {
      this.type = args.type, this.pos = args.pos;
      if (typeof this.type === 'string') {
        this.type = BuildingType.ALL[this.type];
      }
      this.descr = this.type.descr;
    }

    return Building;

  })();

  Experiment = (function(superClass) {
    extend(Experiment, superClass);

    function Experiment(args) {
      Experiment.__super__.constructor.call(this, {
        type: 'Experiment'
      }, this.pos);
      this.experiment = args.experiment;
    }

    return Experiment;

  })(Building);

  Map = (function() {
    function Map(w, h) {
      var i, j;
      this.size = [w, h];
      this.m = (function() {
        var k, ref, results;
        results = [];
        for (i = k = 0, ref = this.size[0] - 1; 0 <= ref ? k <= ref : k >= ref; i = 0 <= ref ? ++k : --k) {
          results.push((function() {
            var l, ref1, results1;
            results1 = [];
            for (j = l = 0, ref1 = this.size[1] - 1; 0 <= ref1 ? l <= ref1 : l >= ref1; j = 0 <= ref1 ? ++l : --l) {
              results1.push({
                resources: {},
                building: null
              });
            }
            return results1;
          }).call(this));
        }
        return results;
      }).call(this);
    }

    Map.prototype.get = function(x, y) {
      assert(x < this.size[0]);
      assert(y < this.size[1]);
      return this.m[x][y];
    };

    Map.prototype.placeBuilding = function(building, pos) {
      var h, i, j, k, l, m, px, py, ref, ref1, ref2, ref3, ref4, ref5, ref6, results, w;
      ref = building.type.size, w = ref[0], h = ref[1];
      px = pos[0], py = pos[1];
      for (i = k = ref1 = px, ref2 = px + w - 1; ref1 <= ref2 ? k <= ref2 : k >= ref2; i = ref1 <= ref2 ? ++k : --k) {
        for (j = l = ref3 = py, ref4 = py + h - 1; ref3 <= ref4 ? l <= ref4 : l >= ref4; j = ref3 <= ref4 ? ++l : --l) {
          if (this.m[i][j].building != null) {
            console.error("already a building at " + i + "×" + j + " (a " + this.m[i][j].building.type.name + ")");
            return;
          }
        }
      }
      building.pos = pos;
      results = [];
      for (i = m = ref5 = px, ref6 = px + w - 1; ref5 <= ref6 ? m <= ref6 : m >= ref6; i = ref5 <= ref6 ? ++m : --m) {
        results.push((function() {
          var n, ref7, ref8, results1;
          results1 = [];
          for (j = n = ref7 = py, ref8 = py + h - 1; ref7 <= ref8 ? n <= ref8 : n >= ref8; j = ref7 <= ref8 ? ++n : --n) {
            results1.push(this.m[i][j].building = building);
          }
          return results1;
        }).call(this));
      }
      return results;
    };

    return Map;

  })();

  Game = (function() {
    function Game() {
      var k, len, name, restype;
      this.map = new Map(20, 20);
      this.buildings = [];
      this.resources = {};
      for (restype = k = 0, len = RESOURCE_TYPES.length; k < len; restype = ++k) {
        name = RESOURCE_TYPES[restype];
        this.resources[name] = new ResourceState({
          type: restype,
          qty: 0
        });
      }
      this._beginTurn();
    }

    Game.prototype._beginTurn = function() {
      var b, k, l, len, len1, name, ref, ref1, res, results;
      ref = this.resources;
      for (res = k = 0, len = ref.length; k < len; res = ++k) {
        name = ref[res];
        res.clearBalance();
      }
      ref1 = this.buildings;
      results = [];
      for (l = 0, len1 = ref1.length; l < len1; l++) {
        b = ref1[l];
        results.push(b.declareResources(this));
      }
      return results;
    };

    Game.prototype.declRes = function(typeName, qty, why) {
      return this.resources[typeName].declare(qty, why);
    };

    Game.prototype.build = function() {
      var args, building, type, where;
      type = arguments[0], where = arguments[1], args = 3 <= arguments.length ? slice.call(arguments, 2) : [];
      if (typeof type === 'string') {
        type = BUILDING_TYPES[type];
      }
      building = (function(func, args, ctor) {
        ctor.prototype = func.prototype;
        var child = new ctor, result = func.apply(child, args);
        return Object(result) === result ? result : child;
      })(Building, [{
        type: type
      }].concat(slice.call(args)), function(){});
      this.map.placeBuilding(building, where);
      this.buildings.push(building);
      return building;
    };

    Game.prototype.endTurn = function() {
      var k, len, name, ref, res, results;
      ref = this.resources;
      results = [];
      for (res = k = 0, len = ref.length; k < len; res = ++k) {
        name = ref[res];
        results.push(res.endTurn());
      }
      return results;
    };

    return Game;

  })();

  new ResourceType({
    name: "Energia",
    symbol: "",
    descr: " Risorsa fondamentale per l'alimentazione di qualsiasi struttura. È\npossibile ricavarla attraverso i \"Pannelli solari\".\n\nNonostante le tempeste di sabbia l'energia solare è la soluzione più\nconveniente per marte rispetto al nucleare. L'irraggiamento solare è\ndi circa 500 W/m2, e i panneli solari ne possono convertire in energia\nelettrica fino al 25%\n[http://www.universetoday.com/21293/despite-dust-storms-solar-power-is-best-for-mars-colonies/]"
  });

  new ResourceType({
    name: "Acqua",
    symbol: "",
    descr: "Risorsa necessaria per la sopravvivenza di astronauti e per\nl'alimentazione di \"Serre\" e dei \"Generatori di ossigeno\". Può essere\nricavata dall' \"Estrattore dell'acqua\" e dal \"Riciclatore dell'acqua\".\n\nL'acqua è un composto chimico di formula molecolare H2O, in cui i due\natomi di idrogeno sono legati all'atomo di ossigeno con legame\ncovalente polare. In condizioni di temperatura e pressione normali si\npresenta come un sistema bifase – costituito da un liquido incolore e\ninsapore (che viene chiamato \"acqua\" in senso stretto) e da un gas\nincolore (detto vapore acqueo) – ma anche come un solido (detto\nghiaccio) nel caso in cui la temperatura sia uguale o inferiore alla\ntemperatura di congelamento. [Wikipedia -\nhttps://it.wikipedia.org/wiki/Acqua]"
  });

  new ResourceType({
    name: "Cibo",
    symbol: "",
    descr: "Risorsa importantissima per permettere la sopravvivenza degli\nastronauti.\n\nLa produzione di cibo localmente è necessaria per una possibile\ncolonizzazione del pianeta, e per rendere gli astronauti più\nindipendenti dalla terra\n[http://www.mars-one.com/faq/health-and-ethics/will-the-astronauts-have-enough-water-food-and-oxygen]"
  });

  new ResourceType({
    name: "Ossigeno",
    symbol: "",
    descr: "Risorsa necessaria la sopravvivenza degli astronauti. L'ossigeno può\nessere prodotto separando l'acqua nelle sue componenti attraverso\nl'elettrolisi.\n\nThe oxygen will be used to provide a breathable atmosphere in the\nliving units, and a portion will be stored in reserve for conditions\nwhen there is less power available, for example at night, and during\ndust storms. The second major component of the living units'\natmosphere, nitrogen, will be extracted directly from the Martian\natmosphere by the life support\nunit. [http://www.mars-one.com/faq/health-and-ethics/will-the-astronauts-have-enough-water-food-and-oxygen] "
  });

  new ResourceType({
    name: "Ricambi",
    symbol: "",
    descr: "Risorsa utile alle \"Officine\" per permettere le\nriparazioni delle varie strutture. Possono essere fornite soltanto\ndalla Terra. "
  });

  new ResourceType({
    name: "Astronauti",
    symbol: "",
    descr: "Permettono di eseguire gli esperimenti e le\nriparazioni. Una persona in media consuma circa 800 kg di cibo e 800\nlitri di acqua all'anno.  "
  });

  new ResourceType({
    name: "Soldi",
    symbol: "",
    descr: "I finanziamenti ottenunti per la missione. Aumentano di\nuna quantità fissa ogni anno e grazie agli esperimenti eseguiti.  "
  });

  new BuildingType({
    name: "Hub",
    declareResources: function(game) {
      return game.declareRes("Wheat", -10, 'Need some for my fam');
    },
    descr: "Il posto che permette agli Astronauti di vivere.\n\nUna possibile idea è di realizzare una struttura ricoperta dal terreno\ndi Marte per migliorare la coibentazione e per migliorare la\nprotezione dalle radiazioni solari\n[https://en.wikipedia.org/wiki/Mars_habitat]\n[http://www.telegraph.co.uk/technology/picture-galleries/11896687/Top-10-Mars-habitats-from-NASA-space-habitat-challenge.html?frame=3456038]\np"
  });

  new BuildingType({
    name: "Magazzino"
  });

  new BuildingType({
    name: "Officina"
  });

  new BuildingType({
    name: "Pannello solare"
  });

  new BuildingType({
    name: "Estrattore acqua"
  });

  new BuildingType({
    name: "Riciclatore acqua"
  });

  new BuildingType({
    name: "Serra",
    size: [4, 3]
  });

  new BuildingType({
    name: "Oxygenator"
  });

  module.exports = {
    RESOURCE_TYPES: RESOURCE_TYPES,
    ResourceType: ResourceType,
    ResourceState: ResourceState,
    BUILDING_TYPES: BUILDING_TYPES,
    BuildingType: BuildingType,
    Building: Building,
    Experiment: Experiment,
    Game: Game
  };

}).call(this);
